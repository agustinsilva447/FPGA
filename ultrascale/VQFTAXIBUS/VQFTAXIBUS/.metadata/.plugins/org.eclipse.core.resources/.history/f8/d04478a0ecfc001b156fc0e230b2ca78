#include "xil_printf.h"
#include "sleep.h"
#include <stdio.h>
#include <math.h>
#include <xtime_l.h>
#include <time.h>
#include <xparameters.h>
#include "xvqftaxibus_hw.h"
#include "xvqftaxibus.h"

#define PI 3.1416
#define L 4			//Cantidad de quits
#define K 2*4		//Dos por la cantidad de qubits
#define M 2*2*2*2	//Dos elevado a la cantidad de qubits

void VQFTAXIBUS(const float E[2*M], float S[2*M])
{
	int j,k;
	float m,n;
	for (j=0;j<M;j++)
	{
		S[j]=0;
		S[j+M]=0;
		for (k=0;k<M;k++)
		{
			m = cos(DOSPI*j*k/M)/sqrt(M);
			n = sin(DOSPI*j*k/M)/sqrt(M);
			S[j]   = S[j]   + (m)   *   E[k]   - (n)   *   E[k+M];
			S[j+M] = S[j+M] + (m)   *   E[k+M] + (n)   *   E[k];
		}
	}
}

unsigned int float_to_u32(float val)
{
	unsigned int result;
	union float_bytes{
		float v;
		unsigned char bytes[4];
	} data;
	data.v = val;
	result = (data.bytes[3]<<24) + (data.bytes[2]<<16) + (data.bytes[1]<<8) + (data.bytes[0]);
	return result;
}

float u32_to_float(unsigned int val)
{
	union{
		float val_float;
		unsigned char bytes[4];
	} data;
	data.bytes[3] = (val >> (8*3)) & 0xff;
	data.bytes[2] = (val >> (8*2)) & 0xff;
	data.bytes[1] = (val >> (8*1)) & 0xff;
	data.bytes[0] = (val >> (8*0)) & 0xff;
	return data.val_float;
}

int main()
{
	int j;
	float ESW[2*M], SSW[2*M], EHW[2*M], SHW[2*M];
	double time_sw, time_hw;

	ESW[0]=1;			ESW[0+Q]=0;
	ESW[1]=0;			ESW[1+Q]=0;
	ESW[2]=0;			ESW[2+Q]=0;
	ESW[3]=0;			ESW[3+Q]=0;
	ESW[4]=0;			ESW[4+Q]=0;
	ESW[5]=0;			ESW[5+Q]=0;
	ESW[6]=0;			ESW[6+Q]=0;
	ESW[7]=0;			ESW[7+Q]=0;
	ESW[8]=0;			ESW[8+Q]=0;
	ESW[9]=0;			ESW[9+Q]=0;
	ESW[10]=0;			ESW[10+Q]=0;
	ESW[11]=0;			ESW[11+Q]=0;
	ESW[12]=0;			ESW[12+Q]=0;
	ESW[13]=0;			ESW[13+Q]=0;
	ESW[14]=0;			ESW[14+Q]=0;
	ESW[15]=0;			ESW[15+Q]=0;


	EHW[0]=1;			EHW[0+Q]=0;
	EHW[1]=0;			EHW[1+Q]=0;
	EHW[2]=0;			EHW[2+Q]=0;
	EHW[3]=0;			EHW[3+Q]=0;
	EHW[4]=0;			EHW[4+Q]=0;
	EHW[5]=0;			EHW[5+Q]=0;
	EHW[6]=0;			EHW[6+Q]=0;
	EHW[7]=0;			EHW[7+Q]=0;
	EHW[8]=0;			EHW[8+Q]=0;
	EHW[9]=0;			EHW[9+Q]=0;
	EHW[10]=0;			EHW[10+Q]=0;
	EHW[11]=0;			EHW[11+Q]=0;
	EHW[12]=0;			EHW[12+Q]=0;
	EHW[13]=0;			EHW[13+Q]=0;
	EHW[14]=0;			EHW[14+Q]=0;
	EHW[15]=0;			EHW[15+Q]=0;


	XTime_GetTime(&tStart);
	VQFTAXIBUS(ESW,SSW);
	XTime_GetTime(&tEnd);
	time_sw = (double)((tEnd - tStart));

// Compienza Hardware
	int status;
	XVqftaxibus goVqftaxibus;
	XVqftaxibus_Config *goVqftaxibus_cfg;
	goVqftaxibus_cfg = XVqftaxibus_LookupConfig(XPAR_XVQFTAXIBUS_0_DEVICE_ID);
	if (!goVqftaxibus_cfg){
		printf("\nError cargando la configuracion de goVqftaxibus.");
	} else {
		printf("\nVqftaxibus configurado correctamente.");
	}
	status = XVqftaxibus_CfgInitialize(&goVqftaxibus, goVqftaxibus_cfg);
	if (status != XST_SUCCESS){
		printf("\nError inicializando goVqftaxibus.");
	} else {
		printf("\nVqftaxibus inicializado correctamente.");
	}
	XVqftaxibus_Initialize(&goVqftaxibus, XPAR_XVQFTAXIBUS_0_DEVICE_ID);

	XTime_GetTime(&tStart);
	XVqftaxibus_Start(&goVqftaxibus);
	while(!XVqftaxibus_IsDone(&goVqftaxibus));
	XTime_GetTime(&tEnd);
	time_hw = (double)((tEnd - tStart));
// Termina Hardware



	printf("----------> SOFTWARE \n");
	printf("\E_SW = \n");
    for (j=0;j<Q;j++)
	{
	printf("%f + i* %f\n",(float)ESW[j],(float)ESW[j+Q]);
	}

	printf("\nS_SW = \n");
	for (j=0;j<Q;j++)
	{
	printf("%f + i* %f\n",(float)SSW[j],(float)SSW[j+Q]);
	}

	printf("----------> HARDWARE \n");
	printf("\E_HW = \n");
    for (j=0;j<Q;j++)
	{
	printf("%f + i* %f\n",(float)EHW[j],(float)EHW[j+Q]);
	}

	printf("\nS = \n");
	for (j=0;j<Q;j++)
	{
	printf("%f + i* %f\n",(float)SHW[j],(float)SHW[j+Q]);
	}

	return 0;
}
