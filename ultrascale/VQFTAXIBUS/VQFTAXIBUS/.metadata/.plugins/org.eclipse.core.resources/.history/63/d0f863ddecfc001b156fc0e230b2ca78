#include "xil_printf.h"
#include "sleep.h"
#include <stdio.h>
#include <math.h>
#include <xtime_l.h>
#include <time.h>
#include <xparameters.h>
#include "xvqftaxibus_hw.h"
#include "xvqftaxibus.h"

#define PI 3.1416
#define L 4			//Cantidad de quits
#define K 2*4		//Dos por la cantidad de qubits
#define M 2*2*2*2	//Dos elevado a la cantidad de qubits

void VQFTAXIBUS(const float E[2*M], float S[2*M])
{
	int j,k;
	float m,n;
	for (j=0;j<M;j++)
	{
		S[j]=0;
		S[j+M]=0;
		for (k=0;k<M;k++)
		{
			m = cos(DOSPI*j*k/M)/sqrt(M);
			n = sin(DOSPI*j*k/M)/sqrt(M);
			S[j]   = S[j]   + (m)   *   E[k]   - (n)   *   E[k+M];
			S[j+M] = S[j+M] + (m)   *   E[k+M] + (n)   *   E[k];
		}
	}
}

unsigned int float_to_u32(float val)
{
	unsigned int result;
	union float_bytes{
		float v;
		unsigned char bytes[4];
	} data;
	data.v = val;
	result = (data.bytes[3]<<24) + (data.bytes[2]<<16) + (data.bytes[1]<<8) + (data.bytes[0]);
	return result;
}

float u32_to_float(unsigned int val)
{
	union{
		float val_float;
		unsigned char bytes[4];
	} data;
	data.bytes[3] = (val >> (8*3)) & 0xff;
	data.bytes[2] = (val >> (8*2)) & 0xff;
	data.bytes[1] = (val >> (8*1)) & 0xff;
	data.bytes[0] = (val >> (8*0)) & 0xff;
	return data.val_float;
}

int main()
{
	int j;
	float E[2*M], SSW[2*M], SHW[2*M];
	unsigned int E_uint[2*M], S_uint[2*M];
	double time_sw, time_hw;

	E[0]=0;			E[0+Q]=0;
	E[1]=0;			E[1+Q]=0;
	E[2]=0;			E[2+Q]=0;
	E[3]=0;			E[3+Q]=0;
	E[4]=0;			E[4+Q]=0;
	E[5]=1;			E[5+Q]=0;
	E[6]=0;			E[6+Q]=0;
	E[7]=0;			E[7+Q]=0;
	E[8]=0;			E[8+Q]=0;
	E[9]=0;			E[9+Q]=0;
	E[10]=0;		E[10+Q]=0;
	E[11]=0;		E[11+Q]=0;
	E[12]=0;		E[12+Q]=0;
	E[13]=0;		E[13+Q]=0;
	E[14]=0;		E[14+Q]=0;
	E[15]=0;		E[15+Q]=0;

	XTime_GetTime(&tStart);
	VQFTAXIBUS(ESW,SSW);
	XTime_GetTime(&tEnd);
	time_sw = (double)((tEnd - tStart));

// Compienza Hardware
	int status;
	XVqftaxibus goVqftaxibus;
	XVqftaxibus_Config *goVqftaxibus_cfg;
	goVqftaxibus_cfg = XVqftaxibus_LookupConfig(XPAR_XVQFTAXIBUS_0_DEVICE_ID);
	if (!goVqftaxibus_cfg){
		printf("\nError cargando la configuracion de goVqftaxibus.");
	} else {
		printf("\nVqftaxibus configurado correctamente.");
	}
	status = XVqftaxibus_CfgInitialize(&goVqftaxibus, goVqftaxibus_cfg);
	if (status != XST_SUCCESS){
		printf("\nError inicializando goVqftaxibus.");
	} else {
		printf("\nVqftaxibus inicializado correctamente.");
	}
	XVqftaxibus_Initialize(&goVqftaxibus, XPAR_XVQFTAXIBUS_0_DEVICE_ID);

    for (j=0;j<Q;j++)
	{
		U_hw[x * N1 + i] = float_to_u32(Ub[x * N1 + i]);
	}
	XHnn_fpga_Write_U_Words(&goHnn_fpga, 0, U_hw, N1 * N1);

	XTime_GetTime(&tStart);
	XVqftaxibus_Start(&goVqftaxibus);
	while(!XVqftaxibus_IsDone(&goVqftaxibus));
	XTime_GetTime(&tEnd);
	time_hw = (double)((tEnd - tStart));


// Termina Hardware

	printf("----------> SOFTWARE \n");
	printf("\E_SW = \n");
    for (j=0;j<Q;j++)
	{
    	printf("%f + i* %f\n",(float)ESW[j],(float)ESW[j+Q]);
	}

	printf("\nS_SW = \n");
	for (j=0;j<Q;j++)
	{
		printf("%f + i* %f\n",(float)SSW[j],(float)SSW[j+Q]);
	}

	printf("----------> HARDWARE \n");
	printf("\E_HW = \n");
    for (j=0;j<Q;j++)
	{
    	printf("%f + i* %f\n",(float)EHW[j],(float)EHW[j+Q]);
	}

	printf("\nS = \n");
	for (j=0;j<Q;j++)
	{
		printf("%f + i* %f\n",(float)SHW[j],(float)SHW[j+Q]);
	}

	return 0;
}
